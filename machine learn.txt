%// Program 1: Write a program to read a digital image. Split and display image into 4 quadrants, up, down, right and left

img = imread('C:\Users\Divyashreenivas\OneDrive\Documents\Divya Chilli Disease photos\cp0\1.jpg');
% Display the original image
figure;
imshow(img);
title('Original Image');

% Get the dimensions of the image
[rows, cols, channels] = size(img);

% Calculate the split points for rows and columns
% Use floor to handle cases with odd dimensions, ensuring integer indices
mid_row = floor(rows / 2);
mid_col = floor(cols / 2);

% --- Split the image into four quadrants ---

% Quadrant 1: Top-Left (Up-Left)
% Rows 1 to mid_row, Columns 1 to mid_col
quad1 = img(1:mid_row, 1:mid_col, :);

% Quadrant 2: Top-Right (Up-Right)
% Rows 1 to mid_row, Columns mid_col+1 to end
quad2 = img(1:mid_row, mid_col+1:end, :);

% Quadrant 3: Bottom-Left (Down-Left)
% Rows mid_row+1 to end, Columns 1 to mid_col
quad3 = img(mid_row+1:end, 1:mid_col, :);

% Quadrant 4: Bottom-Right (Down-Right)
% Rows mid_row+1 to end, Columns mid_col+1 to end
quad4 = img(mid_row+1:end, mid_col+1:end, :);

% --- Display the four quadrants ---

figure;

% Display Top-Left (Up)
subplot(2, 2, 1);
imshow(quad1);
title('Top-Left Quadrant (Up)');

% Display Top-Right (Right side of top half)
subplot(2, 2, 2);
imshow(quad2);
title('Top-Right Quadrant (Right)');

% Display Bottom-Left (Left side of bottom half)
subplot(2, 2, 3);
imshow(quad3);
title('Bottom-Left Quadrant (Left)');

% Display Bottom-Right (Down)
subplot(2, 2, 4);
imshow(quad4);
title('Bottom-Right Quadrant (Down)');

***************************************************


% //Program 2: Write a program to show Rotation, Scaling and Translation of an image

close all;
clear all;
I=imread('C:\Users\USER\Pictures\Screenshots\image1.png');
figure,subplot(2,2,1);imshow(I);title('Original Image');

%Shrink the image by a factor of two.
original = imresize(I, [256 256]);
 subplot(2,2,2);imshow(original);title('Scaled original Image');

% Create a distorted version of the image by resizing and rotating the image. 
% Note that imrotate rotates images in a counterclockwise direction when you specify a positive angle of rotation.


scaleFactor = 0.7;
distorted = imresize(original,scaleFactor);// scaling factor applied to both width and height

theta = 30;
distorted = imrotate(distorted,theta);
subplot(2,2,3);imshow(distorted);title('Rotated Image');

%Translate the image, shifting the image by 15 pixels in the x-direction and 25 pixels in the y-direction.
% Note that, by default, imtranslate displays the translated image within the boundaries (or limits) of the original 256-by-256 image.
% This results in some of the translated image being clipped.
J = imtranslate(original,[15, 25]);
subplot(2,2,4);imshow(J) 
title('Translated Image');

***********************************************************

%//Program 3:Read an image, first apply erosion to the image and then subtract the result from the original. Demonstrate the difference in the edge image if you use dilation instead of erosion.
clc; clear; close all;
I= imread('C:\Users\USER\Desktop\cat.jpg');

% Read image
% I = imread('camersaman.tif');   % You can replace with your own image
if size(I,3) == 3
    I = rgb2gray(I);
end

I = im2uint8(I);   % Ensure correct type

% Structuring element
se = strel('disk', 2);

% Morphological erosion                      
I_eroded = imerode(I, se);

% Edge image using erosion
edge_erosion = imsubtract(I, I_eroded);

% Morphological dilation
I_dilated = imdilate(I, se);

% Edge image using dilation
edge_dilation = imsubtract(I_dilated, I);

% Display results
figure;

subplot(2,3,1), imshow(I), title('Original Image')
subplot(2,3,2), imshow(I_eroded), title('Eroded Image')
subplot(2,3,3), imshow(edge_erosion), title('Edge (Original - Erosion)')

subplot(2,3,4), imshow(I), title('Original Image')
subplot(2,3,5), imshow(I_dilated), title('Dilated Image')
subplot(2,3,6), imshow(edge_dilation), title('Edge (Dilation - Original)')

****************************************************************************************


%// Program 4:Read an image and extract and display low level features such as edges, texture using filtering techniques

clc; clear; close all;
% Read the image
I = imread('C:\Users\USER\Pictures\Screenshots\input file\2.png');   % grayscale image

% Convert to gray if it is gray scale.

if size(I,3) == 3
    Igray = rgb2gray(I);
else
    Igray = I;
end

Igray = im2double(Igray);

%% a) Edge Detection
% Sobel Edge Detection

edge_sobel = edge(Igray, 'sobel');

% Prewitt Edge Detection

edge_prewitt = edge(Igray, 'prewitt');

% Canny Edge Detection

edge_canny = edge(Igray, 'canny');

%% b) Texture Extraction using Filtering

% Laplacian Filter (Second-order derivative)

laplacian_filter = fspecial('laplacian', 0.2);//0.2 is the alpha parameter, which controls the shape or characteristics of the Laplacian filter
laplacian_img = imfilter(Igray, laplacian_filter, 'replicate'); //'replicate' handles the border pixels of the image during filtering. It replicates the border pixel values to create the necessary padding around the image, which helps in processing the edges of the image seamlessly. 

% Gaussian Smoothing (to highlight texture at different scales)

gaussian_filter = fspecial('gaussian', [5 5], 1);
smooth_img = imfilter(Igray, gaussian_filter, 'replicate');

% Sobel Gradient Magnitude (another texture measure)
[Gx, Gy] = imgradientxy(Igray, 'sobel');//This command computes the directional gradients of the grayscale image Igray. Gx contains the gradients in the x-direction (horizontal changes), and Gy contains the gradients in the y-direction (vertical changes) [1]. The 'sobel' argument specifies that the Sobel approximation should be used for this calculation
grad_mag = sqrt(Gx.^2 + Gy.^2);//This command calculates the magnitude of the gradient at each pixel. It applies the Pythagorean theorem (\(a^{2}+b^{2}=c^{2}\)) to the x and y components of the gradient, resulting in the overall strength (magnitude) of the intensity change at each pixel [1]. This final result, grad_mag, is a matrix representing the edge strength across the entire image. 

%% Display Results
figure;

subplot(3,3,1), imshow(I), title('Original Image');
subplot(3,3,2), imshow(edge_sobel), title('Sobel Edges');
subplot(3,3,3), imshow(edge_prewitt), title('Prewitt Edges');
subplot(3,3,4), imshow(edge_canny), title('Canny Edges');
subplot(3,3,5), imshow(laplacian_img, []), title('Laplacian Filter');
subplot(3,3,6), imshow(smooth_img), title('Gaussian Smoothing');
subplot(3,3,7), imshow(grad_mag, []), title('Gradient Magnitude (Sobel)');

*****************************************************************************************

%// Program 5:Demostrate enhancing and segmenting low contrast 2D images

% Read and Display a Low-Contrast Image

clc; clear; close all;

I = imread('C:\Users\USER\Pictures\Screenshots\input file\2.png');   % grayscale image
if size(I,3) == 3
 I = rgb2gray(I);
end

figure, imshow(I), title('Original Low-Contrast Image');

%A)Image Enhancement Methods

%a)Increase and decrease the contrast of an image and display

% Specify a scaling factor
S1 = 1.5;	% Increase brightness

S2 = 0.7;	% Decrease brightness

% Scale the input image to adjust the brightness

brightened_img = I * S1;
darker_img = I * S2;

% Adjust pixel values to the valid range

brightened_img = max(0, min(brightened_img, 255));
darker_img = max(0, min(darker_img, 255));

% Convert to uint8 format to display

brightened_img = uint8(brightened_img);
darker_img = uint8(darker_img);

% Display the input, brightened, and darker images
figure;
subplot(1, 3, 1);
imshow(I);
title('Input Image');
subplot(1, 3, 2);
imshow(brightened_img);
title('Brightened Image');

subplot(1, 3, 3);
imshow(darker_img);
title('Darker Image');

% (b) Histogram Equalization
I_histeq = histeq(I);
figure, imshow(I_histeq), title('Histogram Equalization');

% (c) Adaptive Histogram Equalization (CLAHE – Best for Low Contrast)
I_adapthisteq = adapthisteq(I);

figure, imshow(I_adapthisteq), title('Adaptive Histogram Equalization');


% B) Implement spatial image enhancement function (Point operation)

% (a) Negative
  % Read image
if size(I,3) == 3
    I = rgb2gray(I);       % Convert to grayscale if needed
end

neg = 255 - I;             % Image negative
imshow(neg);
title('Negative Image');

% (b) Log transformation for a grayscale image


if size(I,3) == 3
    I = rgb2gray(I);      % Convert to grayscale
end

I = double(I);            % Convert to double
c = 255 / log(1 + max(I(:)));
logImg = c * log(1 + I);
logImg = uint8(logImg);   % Convert back to uint8
imshow(logImg);
title('Log Transformed Image');

% (c) Power law transformation

if size(I,3) == 3
    I = rgb2gray(I);       % Convert to grayscale
end

I = im2double(I);          % Normalize to [0,1]
gamma = 1.1;               % <1 brightens, >1 darkens
c = 1;
powerImg = c * (I .^ gamma);
imshow(powerImg);
title(['Power Law Transformation, \gamma = ' num2str(gamma)]);

% C) smoothening spatial filter

% a) Average (Mean) filter

I = im2double(I);
h = fspecial('average', [3 3]);   % 3×3 mean filter
smoothImg = imfilter(I, h, 'replicate');
imshow(smoothImg);
title('Mean Filter (3×3)');

% b) box filter

h = ones(5,5) / 25;    % 5×5 box filter
smoothImg = imfilter(I, h, 'replicate');

imshow(smoothImg);
title('Box Filter (5×5)');

% c) gaussian filter

I = im2double(I);
h = fspecial('gaussian', [5 5], 1);  % σ = 1
smoothImg = imfilter(I, h, 'replicate');
imshow(smoothImg);
title('Gaussian Smoothing Filter');

% d) median filter

medianImg = medfilt2(I, [3 3]);
imshow(medianImg);
title('Median Filter (3×3)');

% e) min filter

minImg = ordfilt2(I, 1, ones(3,3));   % 1st order → min
imshow(minImg);
title('Min Filter');

% f) max filter

maxImg = ordfilt2(I, 9, ones(3,3));   % 9th order → max (3×3)
imshow(maxImg);
title('Max Filter');

*****************************************************************************************

% D) Image Segmentation 
% (a) Global Thresholding (Otsu’s Method)
level = graythresh(I_adapthisteq);
BW_otsu = imbinarize(I_adapthisteq, level);

figure, imshow(BW_otsu), title('Otsu Threshold Segmentation');


% (b) Edge-Based Segmentation
edges = edge(I_adapthisteq, 'canny');

figure, imshow(edges), title('Edge-Based Segmentation');
